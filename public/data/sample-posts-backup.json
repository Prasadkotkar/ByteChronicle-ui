[
  {
    "title": "Java Fundamentals for Full Stack Interviews: Core Concepts & OOP",
    "summary": "Master essential Java concepts including OOP principles, collections, exception handling, and multithreading for technical interviews.",
    "author": "Tech Interview Guide",
    "tags": ["Java", "Interview", "OOP", "Backend", "Programming"],
    "featuredImage": "https://images.unsplash.com/photo-1517077304055-6e89abbf09b0?w=800&h=400&fit=crop",
    "content": "# Java Fundamentals for Full Stack Interviews: Core Concepts & OOP\n\n## Object-Oriented Programming (OOP) Principles\n\n### 1. Encapsulation\n```java\npublic class BankAccount {\n    private double balance; // Private field\n    \n    public void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n        }\n    }\n    \n    public double getBalance() {\n        return balance;\n    }\n}\n```\n\n### 2. Inheritance\n```java\npublic class Animal {\n    protected String name;\n    \n    public void eat() {\n        System.out.println(name + \" is eating\");\n    }\n}\n\npublic class Dog extends Animal {\n    public void bark() {\n        System.out.println(name + \" is barking\");\n    }\n    \n    @Override\n    public void eat() {\n        System.out.println(name + \" is eating dog food\");\n    }\n}\n```\n\n### 3. Polymorphism\n```java\nList<Animal> animals = Arrays.asList(\n    new Dog(), new Cat(), new Bird()\n);\n\nfor (Animal animal : animals) {\n    animal.eat(); // Different implementation for each type\n}\n```\n\n### 4. Abstraction\n```java\nabstract class Shape {\n    abstract double calculateArea();\n    \n    public void display() {\n        System.out.println(\"Area: \" + calculateArea());\n    }\n}\n\nclass Circle extends Shape {\n    private double radius;\n    \n    @Override\n    double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n}\n```\n\n## Collections Framework\n\n### ArrayList vs LinkedList\n```java\n// ArrayList - Better for random access\nList<String> arrayList = new ArrayList<>();\narrayList.get(index); // O(1)\n\n// LinkedList - Better for insertions/deletions\nList<String> linkedList = new LinkedList<>();\nlinkedList.add(0, \"element\"); // O(1) at beginning\n```\n\n### HashMap vs TreeMap vs LinkedHashMap\n```java\n// HashMap - No ordering, O(1) operations\nMap<String, Integer> hashMap = new HashMap<>();\n\n// TreeMap - Sorted by keys, O(log n) operations\nMap<String, Integer> treeMap = new TreeMap<>();\n\n// LinkedHashMap - Maintains insertion order\nMap<String, Integer> linkedHashMap = new LinkedHashMap<>();\n```\n\n## Exception Handling\n\n### Try-Catch-Finally\n```java\npublic void readFile(String filename) {\n    FileReader file = null;\n    try {\n        file = new FileReader(filename);\n        // Read file operations\n    } catch (FileNotFoundException e) {\n        System.err.println(\"File not found: \" + e.getMessage());\n    } catch (IOException e) {\n        System.err.println(\"IO Error: \" + e.getMessage());\n    } finally {\n        if (file != null) {\n            try {\n                file.close();\n            } catch (IOException e) {\n                System.err.println(\"Error closing file\");\n            }\n        }\n    }\n}\n```\n\n### Try-with-Resources\n```java\npublic void readFileModern(String filename) {\n    try (FileReader file = new FileReader(filename);\n         BufferedReader reader = new BufferedReader(file)) {\n        \n        String line;\n        while ((line = reader.readLine()) != null) {\n            System.out.println(line);\n        }\n    } catch (IOException e) {\n        System.err.println(\"Error: \" + e.getMessage());\n    }\n    // Resources automatically closed\n}\n```\n\n## Multithreading\n\n### Creating Threads\n```java\n// Extending Thread class\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"Thread running: \" + getName());\n    }\n}\n\n// Implementing Runnable interface (preferred)\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"Runnable running: \" + Thread.currentThread().getName());\n    }\n}\n\n// Usage\nThread thread1 = new MyThread();\nThread thread2 = new Thread(new MyRunnable());\nthread1.start();\nthread2.start();\n```\n\n### Synchronization\n```java\npublic class Counter {\n    private int count = 0;\n    \n    // Synchronized method\n    public synchronized void increment() {\n        count++;\n    }\n    \n    // Synchronized block\n    public void decrement() {\n        synchronized(this) {\n            count--;\n        }\n    }\n    \n    public synchronized int getCount() {\n        return count;\n    }\n}\n```\n\n## Common Interview Questions\n\n### 1. String vs StringBuilder vs StringBuffer\n```java\n// String - Immutable\nString str = \"Hello\";\nstr += \" World\"; // Creates new String object\n\n// StringBuilder - Mutable, not thread-safe\nStringBuilder sb = new StringBuilder(\"Hello\");\nsb.append(\" World\"); // Modifies existing buffer\n\n// StringBuffer - Mutable, thread-safe\nStringBuffer sbf = new StringBuffer(\"Hello\");\nsbf.append(\" World\"); // Synchronized methods\n```\n\n### 2. equals() vs ==\n```java\nString str1 = new String(\"Hello\");\nString str2 = new String(\"Hello\");\nString str3 = \"Hello\";\nString str4 = \"Hello\";\n\nSystem.out.println(str1 == str2);     // false (different objects)\nSystem.out.println(str1.equals(str2)); // true (same content)\nSystem.out.println(str3 == str4);     // true (string pool)\n```\n\n### 3. Checked vs Unchecked Exceptions\n```java\n// Checked Exception - Must be handled\npublic void readFile() throws IOException {\n    FileReader file = new FileReader(\"file.txt\");\n}\n\n// Unchecked Exception - Runtime exception\npublic void divide(int a, int b) {\n    int result = a / b; // May throw ArithmeticException\n}\n```\n\n## Memory Management\n\n### Garbage Collection\n```java\npublic class MemoryExample {\n    public void createObjects() {\n        List<String> list = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n            list.add(\"String \" + i);\n        }\n        // list becomes eligible for GC when method ends\n    }\n    \n    // Force garbage collection (not recommended in production)\n    public void forceGC() {\n        System.gc();\n    }\n}\n```\n\n## Interview Tips\n\n1. **Understand the fundamentals**: OOP principles, collections, exceptions\n2. **Practice coding**: Implement common algorithms and data structures\n3. **Know the differences**: ArrayList vs LinkedList, HashMap vs TreeMap\n4. **Explain your thinking**: Walk through your solution step by step\n5. **Consider edge cases**: Null values, empty collections, boundary conditions\n6. **Optimize when asked**: Discuss time and space complexity\n\n## Key Takeaways\n\n- Master OOP principles with practical examples\n- Understand collection framework and when to use each type\n- Know exception handling best practices\n- Understand multithreading concepts and synchronization\n- Practice common interview problems\n- Be able to explain trade-offs between different approaches\n\nThis foundation will help you tackle most Java-related questions in full stack developer interviews!"
  },
  {
    "title": "Spring Boot Mastery: Building Enterprise Applications for Interviews",
    "summary": "Complete guide to Spring Boot covering dependency injection, auto-configuration, REST APIs, and advanced features for technical interviews.",
    "author": "Tech Interview Guide",
    "tags": ["Spring Boot", "Java", "Framework", "REST API", "Interview"],
    "featuredImage": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop",
    "content": "# Spring Boot Mastery: Building Enterprise Applications for Interviews\n\n## Core Spring Concepts\n\n### Dependency Injection (DI)\n```java\n// Constructor Injection (Recommended)\n@Service\npublic class UserService {\n    private final UserRepository userRepository;\n    private final EmailService emailService;\n    \n    public UserService(UserRepository userRepository, EmailService emailService) {\n        this.userRepository = userRepository;\n        this.emailService = emailService;\n    }\n}\n\n// Field Injection (Not recommended)\n@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n}\n\n// Setter Injection\n@Service\npublic class UserService {\n    private UserRepository userRepository;\n    \n    @Autowired\n    public void setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n```\n\n### Bean Scopes\n```java\n@Component\n@Scope(\"singleton\") // Default - one instance per container\npublic class SingletonBean { }\n\n@Component\n@Scope(\"prototype\") // New instance every time\npublic class PrototypeBean { }\n\n@Component\n@Scope(\"request\") // One instance per HTTP request\npublic class RequestScopedBean { }\n\n@Component\n@Scope(\"session\") // One instance per HTTP session\npublic class SessionScopedBean { }\n```\n\n## Spring Boot Auto-Configuration\n\n### Custom Auto-Configuration\n```java\n@Configuration\n@ConditionalOnClass(DataSource.class)\n@EnableConfigurationProperties(DatabaseProperties.class)\npublic class DatabaseAutoConfiguration {\n    \n    @Bean\n    @ConditionalOnMissingBean\n    public DataSource dataSource(DatabaseProperties properties) {\n        HikariDataSource dataSource = new HikariDataSource();\n        dataSource.setJdbcUrl(properties.getUrl());\n        dataSource.setUsername(properties.getUsername());\n        dataSource.setPassword(properties.getPassword());\n        return dataSource;\n    }\n}\n\n@ConfigurationProperties(prefix = \"app.database\")\npublic class DatabaseProperties {\n    private String url;\n    private String username;\n    private String password;\n    // getters and setters\n}\n```\n\n## REST API Development\n\n### Controller Best Practices\n```java\n@RestController\n@RequestMapping(\"/api/v1/users\")\n@Validated\npublic class UserController {\n    \n    private final UserService userService;\n    \n    public UserController(UserService userService) {\n        this.userService = userService;\n    }\n    \n    @GetMapping\n    public ResponseEntity<Page<UserDTO>> getAllUsers(\n            @RequestParam(defaultValue = \"0\") @Min(0) int page,\n            @RequestParam(defaultValue = \"20\") @Min(1) @Max(100) int size,\n            @RequestParam(required = false) String search) {\n        \n        Pageable pageable = PageRequest.of(page, size);\n        Page<UserDTO> users = userService.findAll(pageable, search);\n        return ResponseEntity.ok(users);\n    }\n    \n    @GetMapping(\"/{id}\")\n    public ResponseEntity<UserDTO> getUserById(@PathVariable @Min(1) Long id) {\n        UserDTO user = userService.findById(id);\n        return ResponseEntity.ok(user);\n    }\n    \n    @PostMapping\n    public ResponseEntity<UserDTO> createUser(@Valid @RequestBody CreateUserRequest request) {\n        UserDTO user = userService.create(request);\n        URI location = ServletUriComponentsBuilder\n                .fromCurrentRequest()\n                .path(\"/{id}\")\n                .buildAndExpand(user.getId())\n                .toUri();\n        return ResponseEntity.created(location).body(user);\n    }\n    \n    @PutMapping(\"/{id}\")\n    public ResponseEntity<UserDTO> updateUser(\n            @PathVariable @Min(1) Long id,\n            @Valid @RequestBody UpdateUserRequest request) {\n        UserDTO user = userService.update(id, request);\n        return ResponseEntity.ok(user);\n    }\n    \n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity<Void> deleteUser(@PathVariable @Min(1) Long id) {\n        userService.delete(id);\n        return ResponseEntity.noContent().build();\n    }\n}\n```\n\n### Exception Handling\n```java\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(UserNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {\n        ErrorResponse error = ErrorResponse.builder()\n                .timestamp(LocalDateTime.now())\n                .status(HttpStatus.NOT_FOUND.value())\n                .error(\"User Not Found\")\n                .message(ex.getMessage())\n                .path(getPath())\n                .build();\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n    }\n    \n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<ValidationErrorResponse> handleValidation(\n            MethodArgumentNotValidException ex) {\n        \n        Map<String, String> errors = new HashMap<>();\n        ex.getBindingResult().getFieldErrors().forEach(error -> \n            errors.put(error.getField(), error.getDefaultMessage())\n        );\n        \n        ValidationErrorResponse response = ValidationErrorResponse.builder()\n                .timestamp(LocalDateTime.now())\n                .status(HttpStatus.BAD_REQUEST.value())\n                .error(\"Validation Failed\")\n                .message(\"Invalid input data\")\n                .fieldErrors(errors)\n                .build();\n                \n        return ResponseEntity.badRequest().body(response);\n    }\n}\n```\n\n## Data Access with Spring Data JPA\n\n### Repository Pattern\n```java\n@Entity\n@Table(name = \"users\")\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(nullable = false, unique = true)\n    private String email;\n    \n    @Column(nullable = false)\n    private String firstName;\n    \n    @Column(nullable = false)\n    private String lastName;\n    \n    @CreationTimestamp\n    private LocalDateTime createdAt;\n    \n    @UpdateTimestamp\n    private LocalDateTime updatedAt;\n    \n    // constructors, getters, setters\n}\n\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    \n    Optional<User> findByEmail(String email);\n    \n    @Query(\"SELECT u FROM User u WHERE u.firstName LIKE %:name% OR u.lastName LIKE %:name%\")\n    Page<User> findByNameContaining(@Param(\"name\") String name, Pageable pageable);\n    \n    @Modifying\n    @Query(\"UPDATE User u SET u.lastName = :lastName WHERE u.id = :id\")\n    int updateLastName(@Param(\"id\") Long id, @Param(\"lastName\") String lastName);\n    \n    @Query(value = \"SELECT * FROM users WHERE created_at > :date\", nativeQuery = true)\n    List<User> findUsersCreatedAfter(@Param(\"date\") LocalDateTime date);\n}\n```\n\n### Service Layer\n```java\n@Service\n@Transactional(readOnly = true)\npublic class UserService {\n    \n    private final UserRepository userRepository;\n    private final UserMapper userMapper;\n    \n    public UserService(UserRepository userRepository, UserMapper userMapper) {\n        this.userRepository = userRepository;\n        this.userMapper = userMapper;\n    }\n    \n    public Page<UserDTO> findAll(Pageable pageable, String search) {\n        Page<User> users = search != null ? \n            userRepository.findByNameContaining(search, pageable) :\n            userRepository.findAll(pageable);\n        return users.map(userMapper::toDTO);\n    }\n    \n    public UserDTO findById(Long id) {\n        User user = userRepository.findById(id)\n                .orElseThrow(() -> new UserNotFoundException(\"User not found with id: \" + id));\n        return userMapper.toDTO(user);\n    }\n    \n    @Transactional\n    public UserDTO create(CreateUserRequest request) {\n        if (userRepository.findByEmail(request.getEmail()).isPresent()) {\n            throw new EmailAlreadyExistsException(\"Email already exists: \" + request.getEmail());\n        }\n        \n        User user = userMapper.toEntity(request);\n        User savedUser = userRepository.save(user);\n        return userMapper.toDTO(savedUser);\n    }\n    \n    @Transactional\n    public UserDTO update(Long id, UpdateUserRequest request) {\n        User user = userRepository.findById(id)\n                .orElseThrow(() -> new UserNotFoundException(\"User not found with id: \" + id));\n        \n        userMapper.updateEntity(request, user);\n        User updatedUser = userRepository.save(user);\n        return userMapper.toDTO(updatedUser);\n    }\n    \n    @Transactional\n    public void delete(Long id) {\n        if (!userRepository.existsById(id)) {\n            throw new UserNotFoundException(\"User not found with id: \" + id);\n        }\n        userRepository.deleteById(id);\n    }\n}\n```\n\n## Configuration and Profiles\n\n### Application Properties\n```yaml\n# application.yml\nspring:\n  profiles:\n    active: dev\n  datasource:\n    url: ${DB_URL:jdbc:h2:mem:testdb}\n    username: ${DB_USERNAME:sa}\n    password: ${DB_PASSWORD:}\n  jpa:\n    hibernate:\n      ddl-auto: ${DDL_AUTO:create-drop}\n    show-sql: ${SHOW_SQL:true}\n    properties:\n      hibernate:\n        format_sql: true\n  cache:\n    type: redis\n    redis:\n      host: ${REDIS_HOST:localhost}\n      port: ${REDIS_PORT:6379}\n\nlogging:\n  level:\n    com.example: ${LOG_LEVEL:DEBUG}\n    org.springframework.security: DEBUG\n\napp:\n  jwt:\n    secret: ${JWT_SECRET:mySecretKey}\n    expiration: ${JWT_EXPIRATION:86400000}\n  cors:\n    allowed-origins: ${CORS_ORIGINS:http://localhost:3000}\n```\n\n### Profile-Specific Configuration\n```yaml\n# application-dev.yml\nspring:\n  datasource:\n    url: jdbc:h2:mem:devdb\n  h2:\n    console:\n      enabled: true\n\n---\n# application-prod.yml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/proddb\n    username: ${DB_USERNAME}\n    password: ${DB_PASSWORD}\n  jpa:\n    hibernate:\n      ddl-auto: validate\n    show-sql: false\n\nlogging:\n  level:\n    com.example: INFO\n```\n\n## Testing\n\n### Unit Testing\n```java\n@ExtendWith(MockitoExtension.class)\nclass UserServiceTest {\n    \n    @Mock\n    private UserRepository userRepository;\n    \n    @Mock\n    private UserMapper userMapper;\n    \n    @InjectMocks\n    private UserService userService;\n    \n    @Test\n    void shouldFindUserById() {\n        // Given\n        Long userId = 1L;\n        User user = new User();\n        user.setId(userId);\n        UserDTO expectedDTO = new UserDTO();\n        \n        when(userRepository.findById(userId)).thenReturn(Optional.of(user));\n        when(userMapper.toDTO(user)).thenReturn(expectedDTO);\n        \n        // When\n        UserDTO result = userService.findById(userId);\n        \n        // Then\n        assertThat(result).isEqualTo(expectedDTO);\n        verify(userRepository).findById(userId);\n        verify(userMapper).toDTO(user);\n    }\n    \n    @Test\n    void shouldThrowExceptionWhenUserNotFound() {\n        // Given\n        Long userId = 1L;\n        when(userRepository.findById(userId)).thenReturn(Optional.empty());\n        \n        // When & Then\n        assertThatThrownBy(() -> userService.findById(userId))\n                .isInstanceOf(UserNotFoundException.class)\n                .hasMessage(\"User not found with id: \" + userId);\n    }\n}\n```\n\n### Integration Testing\n```java\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)\n@Testcontainers\nclass UserControllerIntegrationTest {\n    \n    @Container\n    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(\"postgres:13\")\n            .withDatabaseName(\"testdb\")\n            .withUsername(\"test\")\n            .withPassword(\"test\");\n    \n    @Autowired\n    private TestRestTemplate restTemplate;\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @DynamicPropertySource\n    static void configureProperties(DynamicPropertyRegistry registry) {\n        registry.add(\"spring.datasource.url\", postgres::getJdbcUrl);\n        registry.add(\"spring.datasource.username\", postgres::getUsername);\n        registry.add(\"spring.datasource.password\", postgres::getPassword);\n    }\n    \n    @Test\n    void shouldCreateUser() {\n        // Given\n        CreateUserRequest request = CreateUserRequest.builder()\n                .email(\"test@example.com\")\n                .firstName(\"John\")\n                .lastName(\"Doe\")\n                .build();\n        \n        // When\n        ResponseEntity<UserDTO> response = restTemplate.postForEntity(\n                \"/api/v1/users\", request, UserDTO.class);\n        \n        // Then\n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);\n        assertThat(response.getBody().getEmail()).isEqualTo(\"test@example.com\");\n        assertThat(userRepository.findByEmail(\"test@example.com\")).isPresent();\n    }\n}\n```\n\n## Common Interview Questions\n\n### 1. Spring vs Spring Boot\n- **Spring**: Comprehensive framework requiring manual configuration\n- **Spring Boot**: Opinionated framework with auto-configuration and embedded servers\n\n### 2. Bean Lifecycle\n1. Instantiation\n2. Populate properties\n3. BeanNameAware.setBeanName()\n4. BeanFactoryAware.setBeanFactory()\n5. ApplicationContextAware.setApplicationContext()\n6. BeanPostProcessor.postProcessBeforeInitialization()\n7. @PostConstruct or InitializingBean.afterPropertiesSet()\n8. Custom init method\n9. BeanPostProcessor.postProcessAfterInitialization()\n10. Bean ready for use\n11. @PreDestroy or DisposableBean.destroy()\n12. Custom destroy method\n\n### 3. Circular Dependencies\n```java\n// Problem\n@Service\nclass ServiceA {\n    @Autowired\n    private ServiceB serviceB;\n}\n\n@Service\nclass ServiceB {\n    @Autowired\n    private ServiceA serviceA;\n}\n\n// Solutions:\n// 1. Constructor injection with @Lazy\n@Service\nclass ServiceA {\n    private final ServiceB serviceB;\n    \n    public ServiceA(@Lazy ServiceB serviceB) {\n        this.serviceB = serviceB;\n    }\n}\n\n// 2. Setter injection\n// 3. @PostConstruct\n// 4. Redesign to avoid circular dependency\n```\n\n## Key Interview Points\n\n1. **Dependency Injection**: Constructor > Setter > Field injection\n2. **Auto-Configuration**: How Spring Boot reduces boilerplate\n3. **Profiles**: Environment-specific configurations\n4. **Exception Handling**: Global exception handlers\n5. **Testing**: Unit tests with mocks, integration tests with TestContainers\n6. **Security**: Authentication, authorization, CORS\n7. **Caching**: @Cacheable, @CacheEvict, @CachePut\n8. **Transactions**: @Transactional, propagation, isolation\n\nMaster these concepts and you'll be well-prepared for Spring Boot interview questions!"
  },
  {
    "title": "Java Mastery for Interviews: Core Concepts and Theory",
    "summary": "Essential Java concepts including OOP principles, memory management, and key features every full stack developer should master for technical interviews.",
    "author": "Tech Interview Guide",
    "tags": ["Java", "Interview", "Backend", "Programming", "Theory"],
    "featuredImage": "https://images.unsplash.com/photo-1517077304055-6e89abbf09b0?w=800&h=400&fit=crop",
    "content": "# Java Mastery for Interviews: Core Concepts and Theory\n\n## Object-Oriented Programming Fundamentals\n\n### The Four Pillars of OOP\n\n**Encapsulation** is the bundling of data and methods that operate on that data within a single unit. It provides data hiding and protects the internal state of objects from unauthorized access.\n\n**Inheritance** allows classes to inherit properties and methods from parent classes, promoting code reusability and establishing hierarchical relationships between classes.\n\n**Polymorphism** enables objects of different types to be treated as instances of the same type through a common interface. It includes method overriding and method overloading.\n\n**Abstraction** hides complex implementation details while exposing only essential features. It's achieved through abstract classes and interfaces.\n\n```java\n// Essential OOP example\npublic abstract class Animal {\n    protected String name;\n    public abstract void makeSound();\n    public void sleep() { /* implementation */ }\n}\n\npublic class Dog extends Animal {\n    @Override\n    public void makeSound() { System.out.println(\"Woof!\"); }\n}\n```\n\n## Memory Management and JVM Architecture\n\n### JVM Memory Structure\n\n**Heap Memory** stores objects and instance variables. It's divided into Young Generation (Eden, Survivor spaces) and Old Generation (Tenured space).\n\n**Stack Memory** stores method calls, local variables, and partial results. Each thread has its own stack.\n\n**Method Area** stores class-level information including method bytecode, constant pool, and static variables.\n\n**PC Registers** track the currently executing instruction for each thread.\n\n### Garbage Collection\n\nJava automatically manages memory through garbage collection, which removes unreferenced objects. Key GC algorithms include:\n- **Serial GC**: Single-threaded, suitable for small applications\n- **Parallel GC**: Multi-threaded, good for throughput\n- **G1 GC**: Low-latency collector for large heaps\n- **ZGC/Shenandoah**: Ultra-low latency collectors\n\n## Collections Framework\n\n### Core Interfaces and Implementations\n\n**List Interface**: Ordered collections allowing duplicates\n- ArrayList: Dynamic array, O(1) access, O(n) insertion\n- LinkedList: Doubly-linked list, O(n) access, O(1) insertion\n- Vector: Synchronized ArrayList (legacy)\n\n**Set Interface**: Collections without duplicates\n- HashSet: Hash table implementation, O(1) operations\n- TreeSet: Red-black tree, O(log n) operations, sorted\n- LinkedHashSet: Hash table + linked list, maintains insertion order\n\n**Map Interface**: Key-value pairs\n- HashMap: Hash table, O(1) operations, no ordering\n- TreeMap: Red-black tree, O(log n) operations, sorted by keys\n- LinkedHashMap: Hash table + linked list, maintains order\n\n## Concurrency and Multithreading\n\n### Thread Fundamentals\n\nJava supports multithreading through the Thread class and Runnable interface. Threads share memory space but have separate execution paths.\n\n**Thread States**: NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED\n\n**Synchronization** prevents race conditions through:\n- synchronized methods and blocks\n- volatile keyword for visibility\n- Atomic classes for lock-free operations\n- java.util.concurrent package utilities\n\n### Executor Framework\n\nThe Executor framework provides higher-level thread management:\n- ThreadPoolExecutor for custom thread pools\n- ScheduledExecutorService for delayed/periodic tasks\n- CompletableFuture for asynchronous programming\n\n## Exception Handling\n\n### Exception Hierarchy\n\n**Checked Exceptions**: Must be handled or declared (IOException, SQLException)\n**Unchecked Exceptions**: Runtime exceptions (NullPointerException, IllegalArgumentException)\n**Errors**: System-level problems (OutOfMemoryError, StackOverflowError)\n\n### Best Practices\n\n- Use try-with-resources for automatic resource management\n- Create custom exceptions for domain-specific errors\n- Follow the fail-fast principle\n- Log exceptions appropriately\n\n## Java 8+ Modern Features\n\n### Lambda Expressions and Functional Interfaces\n\nLambda expressions enable functional programming paradigms in Java. They work with functional interfaces (interfaces with single abstract methods).\n\n### Stream API\n\nStreams provide declarative data processing with operations like filter, map, reduce, and collect. They support parallel processing for performance.\n\n### Optional Class\n\nOptional helps avoid NullPointerException by explicitly representing the absence of values.\n\n## String Handling\n\n### String Immutability\n\nStrings in Java are immutable objects stored in the string pool for memory efficiency. String operations create new objects rather than modifying existing ones.\n\n**StringBuilder/StringBuffer**: Mutable alternatives for string manipulation\n- StringBuilder: Not thread-safe, better performance\n- StringBuffer: Thread-safe, synchronized methods\n\n## Key Interview Topics\n\n### Memory Leaks\nCommon causes include:\n- Static collections holding references\n- Unclosed resources (streams, connections)\n- Event listeners not removed\n- ThreadLocal variables not cleared\n\n### Performance Considerations\n- Choose appropriate collection types\n- Use primitive collections when possible\n- Implement equals() and hashCode() correctly\n- Consider immutable objects for thread safety\n\n### Design Patterns\nCommon patterns in Java:\n- Singleton: Single instance per JVM\n- Factory: Object creation abstraction\n- Observer: Event notification system\n- Strategy: Algorithm encapsulation\n\n## Interview Preparation Tips\n\n1. **Understand JVM internals**: Memory areas, garbage collection, class loading\n2. **Master collections**: When to use each type, performance characteristics\n3. **Know concurrency**: Thread safety, synchronization mechanisms\n4. **Practice exception handling**: Checked vs unchecked, best practices\n5. **Study modern features**: Lambdas, streams, optional\n6. **Understand design patterns**: Common patterns and their use cases\n\nJava's robust ecosystem, platform independence, and strong typing make it ideal for enterprise applications. Focus on understanding core concepts deeply rather than memorizing syntax."
  },
  {
    "title": "Spring Boot Framework: Enterprise Java Development Simplified",
    "summary": "Understanding Spring Boot's auto-configuration, dependency injection, and enterprise features for building scalable Java applications in interviews.",
    "author": "Tech Interview Guide",
    "tags": ["Spring Boot", "Java", "Framework", "Enterprise", "Interview"],
    "featuredImage": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop",
    "content": "# Spring Boot Framework: Enterprise Java Development Simplified\n\n## Spring Boot Fundamentals\n\n### What is Spring Boot?\n\nSpring Boot is an opinionated framework built on top of the Spring Framework that simplifies the development of production-ready applications. It eliminates boilerplate configuration and provides embedded servers, making deployment straightforward.\n\n### Key Principles\n\n**Convention over Configuration**: Spring Boot follows sensible defaults, reducing the need for explicit configuration.\n\n**Opinionated Defaults**: Provides pre-configured setups for common use cases while allowing customization when needed.\n\n**Production-Ready**: Includes built-in features for monitoring, health checks, and metrics.\n\n**Microservices-Friendly**: Designed to support microservices architecture with minimal overhead.\n\n## Dependency Injection and IoC Container\n\n### Inversion of Control (IoC)\n\nIoC is a design principle where object creation and dependency management are handled by the framework rather than the application code. This promotes loose coupling and easier testing.\n\n### Dependency Injection Types\n\n**Constructor Injection** (Recommended): Dependencies are provided through class constructors, ensuring immutable dependencies and fail-fast behavior.\n\n**Setter Injection**: Dependencies are set through setter methods, allowing optional dependencies and circular references.\n\n**Field Injection**: Dependencies are injected directly into fields using @Autowired, though this approach is discouraged due to testing difficulties.\n\n```java\n@Service\npublic class UserService {\n    private final UserRepository userRepository;\n    \n    // Constructor injection - preferred approach\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n```\n\n## Auto-Configuration Magic\n\n### How Auto-Configuration Works\n\nSpring Boot's auto-configuration automatically configures beans based on:\n- Classpath dependencies\n- Existing bean definitions\n- Configuration properties\n- Conditional annotations\n\n### Key Auto-Configuration Classes\n\n**DataSourceAutoConfiguration**: Automatically configures database connections\n**WebMvcAutoConfiguration**: Sets up Spring MVC components\n**SecurityAutoConfiguration**: Configures basic security settings\n**JpaRepositoriesAutoConfiguration**: Enables JPA repositories\n\n### Conditional Annotations\n\n- @ConditionalOnClass: Configuration applies when specific classes are present\n- @ConditionalOnMissingBean: Creates bean only if it doesn't already exist\n- @ConditionalOnProperty: Activates based on configuration properties\n- @ConditionalOnProfile: Applies to specific application profiles\n\n## Application Properties and Profiles\n\n### Configuration Management\n\nSpring Boot supports externalized configuration through:\n- application.properties/application.yml files\n- Environment variables\n- Command-line arguments\n- @ConfigurationProperties classes\n\n### Profile-Based Configuration\n\nProfiles allow different configurations for different environments:\n- application-dev.properties for development\n- application-prod.properties for production\n- application-test.properties for testing\n\n### Configuration Properties Binding\n\n```java\n@ConfigurationProperties(prefix = \"app.database\")\npublic class DatabaseProperties {\n    private String url;\n    private String username;\n    private int maxConnections = 10;\n    // getters and setters\n}\n```\n\n## Spring Boot Starters\n\n### What are Starters?\n\nStarters are dependency descriptors that bring together related dependencies for specific functionality. They simplify dependency management and ensure compatible versions.\n\n### Common Starters\n\n**spring-boot-starter-web**: Web applications with Spring MVC\n**spring-boot-starter-data-jpa**: JPA with Hibernate\n**spring-boot-starter-security**: Spring Security\n**spring-boot-starter-test**: Testing frameworks\n**spring-boot-starter-actuator**: Production monitoring\n\n## Bean Lifecycle and Scopes\n\n### Bean Scopes\n\n**Singleton** (Default): One instance per Spring container\n**Prototype**: New instance for each request\n**Request**: One instance per HTTP request (web applications)\n**Session**: One instance per HTTP session (web applications)\n**Application**: One instance per ServletContext\n\n### Bean Lifecycle Callbacks\n\n1. **Instantiation**: Bean object creation\n2. **Dependency Injection**: Setting properties and dependencies\n3. **Initialization**: @PostConstruct methods and InitializingBean\n4. **Ready for Use**: Bean is fully initialized\n5. **Destruction**: @PreDestroy methods and DisposableBean\n\n## Spring Boot Actuator\n\n### Production Monitoring\n\nActuator provides production-ready features:\n- Health checks (/actuator/health)\n- Metrics (/actuator/metrics)\n- Environment information (/actuator/env)\n- Configuration properties (/actuator/configprops)\n- Thread dumps (/actuator/threaddump)\n\n### Custom Health Indicators\n\nCreate custom health checks for application-specific components:\n\n```java\n@Component\npublic class DatabaseHealthIndicator implements HealthIndicator {\n    @Override\n    public Health health() {\n        // Check database connectivity\n        return Health.up().withDetail(\"database\", \"Available\").build();\n    }\n}\n```\n\n## Testing in Spring Boot\n\n### Testing Annotations\n\n**@SpringBootTest**: Loads complete application context\n**@WebMvcTest**: Tests web layer components\n**@DataJpaTest**: Tests JPA repositories\n**@MockBean**: Creates mock beans in application context\n**@TestPropertySource**: Overrides properties for tests\n\n### Test Slices\n\nSpring Boot provides test slices that load only specific parts of the application:\n- @WebMvcTest for controllers\n- @DataJpaTest for repositories\n- @JsonTest for JSON serialization\n- @RestClientTest for REST clients\n\n## Error Handling and Validation\n\n### Global Exception Handling\n\n@ControllerAdvice allows centralized exception handling across the application:\n\n```java\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n    @ExceptionHandler(ValidationException.class)\n    public ResponseEntity<ErrorResponse> handleValidation(ValidationException ex) {\n        return ResponseEntity.badRequest().body(new ErrorResponse(ex.getMessage()));\n    }\n}\n```\n\n### Bean Validation\n\nSpring Boot integrates with Bean Validation (JSR-303) for automatic validation:\n- @Valid for method parameters\n- @NotNull, @NotEmpty, @Size for field validation\n- Custom validators for complex validation logic\n\n## Security Integration\n\n### Spring Security Auto-Configuration\n\nSpring Boot automatically configures basic security when Spring Security is on the classpath:\n- Default login page\n- Basic authentication\n- CSRF protection\n- Security headers\n\n### Customizing Security\n\nOverride default security configuration:\n\n```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        return http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/public/**\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .build();\n    }\n}\n```\n\n## Performance and Optimization\n\n### Lazy Initialization\n\nEnable lazy initialization to improve startup time:\n```properties\nspring.main.lazy-initialization=true\n```\n\n### Connection Pooling\n\nSpring Boot auto-configures HikariCP for database connection pooling:\n```properties\nspring.datasource.hikari.maximum-pool-size=20\nspring.datasource.hikari.minimum-idle=5\n```\n\n### Caching\n\nEnable caching with @EnableCaching and cache annotations:\n- @Cacheable: Cache method results\n- @CacheEvict: Remove cache entries\n- @CachePut: Update cache entries\n\n## Common Interview Questions\n\n### Spring vs Spring Boot\n- **Spring**: Comprehensive framework requiring manual configuration\n- **Spring Boot**: Opinionated framework with auto-configuration and embedded servers\n- **Benefits**: Faster development, reduced boilerplate, production-ready features\n\n### Auto-Configuration Process\n1. Classpath scanning for auto-configuration classes\n2. Conditional evaluation based on @Conditional annotations\n3. Bean creation and configuration\n4. Property binding and customization\n\n### Embedded Servers\nSpring Boot includes embedded servers (Tomcat, Jetty, Undertow) eliminating the need for external server deployment.\n\n### Externalized Configuration\nConfiguration can be externalized through properties files, environment variables, and command-line arguments, following a specific precedence order.\n\n## Best Practices\n\n### Configuration Management\n- Use @ConfigurationProperties for type-safe configuration\n- Leverage profiles for environment-specific settings\n- Externalize sensitive information using environment variables\n\n### Dependency Injection\n- Prefer constructor injection over field injection\n- Use @Lazy for expensive beans that aren't always needed\n- Avoid circular dependencies through proper design\n\n### Testing Strategy\n- Use test slices for focused testing\n- Mock external dependencies with @MockBean\n- Test configuration with @TestPropertySource\n\n### Production Readiness\n- Enable Actuator for monitoring\n- Configure proper logging levels\n- Use connection pooling for databases\n- Implement health checks for critical components\n\n## Interview Preparation Tips\n\n1. **Understand auto-configuration**: How Spring Boot reduces configuration overhead\n2. **Know dependency injection**: Different types and when to use each\n3. **Master profiles**: Environment-specific configuration management\n4. **Study Actuator**: Production monitoring and management features\n5. **Practice testing**: Different test slices and their use cases\n6. **Learn security basics**: How Spring Security integrates with Spring Boot\n\nSpring Boot's convention-over-configuration approach and production-ready features make it the preferred choice for enterprise Java development. Focus on understanding the underlying principles rather than memorizing configuration details."
  },
  {
    "title": "Spring Security: Authentication and Authorization Mastery",
    "summary": "Comprehensive guide to Spring Security concepts, authentication mechanisms, authorization strategies, and security best practices for enterprise applications.",
    "author": "Tech Interview Guide",
    "tags": ["Spring Security", "Authentication", "Authorization", "Security", "Interview"],
    "featuredImage": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit=crop",
    "content": "# Spring Security: Authentication and Authorization Mastery\n\n## Spring Security Fundamentals\n\n### What is Spring Security?\n\nSpring Security is a comprehensive security framework that provides authentication, authorization, and protection against common security vulnerabilities. It integrates seamlessly with Spring applications and supports various authentication mechanisms.\n\n### Core Security Concepts\n\n**Authentication** answers \"Who are you?\" - the process of verifying user identity through credentials like username/password, tokens, or certificates.\n\n**Authorization** answers \"What can you do?\" - the process of determining what resources and operations an authenticated user can access.\n\n**Principal** represents the currently authenticated user or system.\n\n**Authorities/Roles** define permissions and access levels for different users.\n\n## Security Architecture\n\n### Security Filter Chain\n\nSpring Security uses a chain of filters to process security concerns:\n\n1. **SecurityContextPersistenceFilter**: Manages SecurityContext across requests\n2. **UsernamePasswordAuthenticationFilter**: Processes login form submissions\n3. **BasicAuthenticationFilter**: Handles HTTP Basic authentication\n4. **AuthorizationFilter**: Enforces access control decisions\n5. **ExceptionTranslationFilter**: Handles security exceptions\n\n### Security Context\n\nThe SecurityContext holds authentication information for the current thread. It's managed by the SecurityContextHolder and can be accessed throughout the application.\n\n### Authentication Manager\n\nThe AuthenticationManager is responsible for processing authentication requests. It delegates to AuthenticationProviders to perform actual authentication logic.\n\n## Authentication Mechanisms\n\n### Form-Based Authentication\n\nTraditional web form authentication where users submit credentials through an HTML form. Spring Security provides default login pages and customizable authentication success/failure handlers.\n\n### HTTP Basic Authentication\n\nSimple authentication scheme where credentials are sent in the Authorization header. Suitable for APIs but credentials are base64 encoded (not encrypted).\n\n### JWT (JSON Web Token) Authentication\n\nStateless authentication using self-contained tokens that carry user information and claims. Ideal for microservices and single-page applications.\n\n**JWT Structure**:\n- Header: Token type and signing algorithm\n- Payload: Claims about the user and token\n- Signature: Verification of token integrity\n\n### OAuth 2.0 and OpenID Connect\n\nOAuth 2.0 provides authorization framework for third-party access, while OpenID Connect adds authentication layer on top of OAuth 2.0.\n\n**OAuth 2.0 Flows**:\n- Authorization Code: Most secure, suitable for web applications\n- Client Credentials: For service-to-service communication\n- Resource Owner Password: Direct credential exchange (discouraged)\n\n## Authorization Strategies\n\n### Role-Based Access Control (RBAC)\n\nUsers are assigned roles, and roles have associated permissions. Simple and widely used approach.\n\n```java\n@PreAuthorize(\"hasRole('ADMIN')\")\npublic void deleteUser(Long userId) {\n    // Only users with ADMIN role can execute\n}\n```\n\n### Method-Level Security\n\nSecurity annotations can be applied directly to methods:\n\n**@PreAuthorize**: Checks conditions before method execution\n**@PostAuthorize**: Checks conditions after method execution\n**@Secured**: Simple role-based authorization\n**@RolesAllowed**: JSR-250 standard annotation\n\n### URL-Based Security\n\nDefine security rules for URL patterns:\n\n```java\nhttp.authorizeHttpRequests(authz -> authz\n    .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n    .requestMatchers(\"/user/**\").hasAnyRole(\"USER\", \"ADMIN\")\n    .requestMatchers(\"/public/**\").permitAll()\n    .anyRequest().authenticated()\n);\n```\n\n### Expression-Based Access Control\n\nSpring Security Expression Language (SpEL) provides flexible authorization:\n\n- `hasRole('ROLE')`: Check if user has specific role\n- `hasAuthority('PERMISSION')`: Check specific authority\n- `principal.username`: Access principal properties\n- `authentication.name`: Get authenticated user name\n- `#userId == authentication.principal.id`: Parameter-based checks\n\n## Password Security\n\n### Password Encoding\n\nNever store passwords in plain text. Spring Security provides various password encoders:\n\n**BCryptPasswordEncoder**: Uses bcrypt hashing algorithm (recommended)\n**SCryptPasswordEncoder**: Memory-hard algorithm resistant to hardware attacks\n**Pbkdf2PasswordEncoder**: PBKDF2 algorithm with configurable iterations\n**NoOpPasswordEncoder**: Plain text (only for development/testing)\n\n### Password Policies\n\nImplement strong password policies:\n- Minimum length requirements\n- Character complexity rules\n- Password history to prevent reuse\n- Account lockout after failed attempts\n- Password expiration policies\n\n## Session Management\n\n### Session Security\n\nSpring Security provides session management features:\n\n**Session Fixation Protection**: Prevents session hijacking by changing session ID after authentication\n**Concurrent Session Control**: Limits number of concurrent sessions per user\n**Session Timeout**: Automatically invalidates inactive sessions\n**Secure Session Cookies**: HttpOnly and Secure flags for session cookies\n\n### Stateless Authentication\n\nFor REST APIs and microservices, stateless authentication using JWT tokens eliminates server-side session storage:\n\n```java\nhttp.sessionManagement(session -> session\n    .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n);\n```\n\n## CSRF Protection\n\n### Cross-Site Request Forgery\n\nCSRF attacks trick users into performing unintended actions. Spring Security provides CSRF protection through:\n\n- CSRF tokens in forms and AJAX requests\n- SameSite cookie attribute\n- Referer header validation\n- Custom CSRF token repositories\n\n### CSRF Configuration\n\n```java\nhttp.csrf(csrf -> csrf\n    .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())\n    .ignoringRequestMatchers(\"/api/**\") // Disable for APIs using JWT\n);\n```\n\n## CORS (Cross-Origin Resource Sharing)\n\n### Cross-Origin Requests\n\nCORS allows web applications to make requests to different domains. Spring Security integrates with Spring MVC's CORS support:\n\n```java\n@CrossOrigin(origins = \"http://localhost:3000\")\n@RestController\npublic class ApiController {\n    // Controller methods\n}\n```\n\n### Global CORS Configuration\n\n```java\n@Bean\npublic CorsConfigurationSource corsConfigurationSource() {\n    CorsConfiguration configuration = new CorsConfiguration();\n    configuration.setAllowedOrigins(Arrays.asList(\"http://localhost:3000\"));\n    configuration.setAllowedMethods(Arrays.asList(\"GET\", \"POST\", \"PUT\", \"DELETE\"));\n    configuration.setAllowedHeaders(Arrays.asList(\"*\"));\n    configuration.setAllowCredentials(true);\n    \n    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n    source.registerCorsConfiguration(\"/**\", configuration);\n    return source;\n}\n```\n\n## Security Headers\n\n### HTTP Security Headers\n\nSpring Security automatically adds security headers:\n\n**X-Content-Type-Options**: Prevents MIME type sniffing\n**X-Frame-Options**: Prevents clickjacking attacks\n**X-XSS-Protection**: Enables XSS filtering in browsers\n**Strict-Transport-Security**: Enforces HTTPS connections\n**Content-Security-Policy**: Prevents code injection attacks\n\n### Custom Security Headers\n\n```java\nhttp.headers(headers -> headers\n    .frameOptions().deny()\n    .contentTypeOptions().and()\n    .httpStrictTransportSecurity(hsts -> hsts\n        .maxAgeInSeconds(31536000)\n        .includeSubdomains(true)\n    )\n);\n```\n\n## Testing Security\n\n### Security Testing Annotations\n\n**@WithMockUser**: Creates mock authenticated user for tests\n**@WithUserDetails**: Loads user from UserDetailsService\n**@WithSecurityContext**: Custom security context for tests\n**@WithAnonymousUser**: Tests with anonymous user\n\n### Testing Security Configuration\n\n```java\n@Test\n@WithMockUser(roles = \"ADMIN\")\nvoid shouldAllowAdminAccess() throws Exception {\n    mockMvc.perform(get(\"/admin/users\"))\n           .andExpect(status().isOk());\n}\n\n@Test\nvoid shouldRequireAuthentication() throws Exception {\n    mockMvc.perform(get(\"/secure/data\"))\n           .andExpect(status().isUnauthorized());\n}\n```\n\n## Common Security Vulnerabilities\n\n### OWASP Top 10 Protection\n\n1. **Injection**: Use parameterized queries, input validation\n2. **Broken Authentication**: Implement strong authentication mechanisms\n3. **Sensitive Data Exposure**: Encrypt data at rest and in transit\n4. **XML External Entities**: Disable XML external entity processing\n5. **Broken Access Control**: Implement proper authorization checks\n6. **Security Misconfiguration**: Follow security best practices\n7. **Cross-Site Scripting**: Sanitize user input, use CSP headers\n8. **Insecure Deserialization**: Validate serialized data\n9. **Known Vulnerabilities**: Keep dependencies updated\n10. **Insufficient Logging**: Implement comprehensive security logging\n\n## Best Practices\n\n### Authentication Best Practices\n\n- Use strong password policies and encoding\n- Implement multi-factor authentication for sensitive operations\n- Use secure session management\n- Implement account lockout mechanisms\n- Log authentication events for monitoring\n\n### Authorization Best Practices\n\n- Follow principle of least privilege\n- Use role-based access control appropriately\n- Implement defense in depth with multiple authorization layers\n- Regularly review and audit permissions\n- Use method-level security for fine-grained control\n\n### General Security Practices\n\n- Keep Spring Security and dependencies updated\n- Use HTTPS in production environments\n- Implement proper error handling without information disclosure\n- Regular security testing and code reviews\n- Monitor and log security events\n\n## Common Interview Questions\n\n### Authentication vs Authorization\n- **Authentication**: Verifying user identity (login process)\n- **Authorization**: Determining user permissions (access control)\n- **Example**: Login with username/password (authentication), then check if user can delete files (authorization)\n\n### JWT vs Session-Based Authentication\n- **JWT**: Stateless, scalable, suitable for microservices\n- **Sessions**: Stateful, server-side storage, traditional web applications\n- **Trade-offs**: JWT can't be revoked easily, sessions require server memory\n\n### CSRF vs XSS\n- **CSRF**: Tricks user into performing unintended actions\n- **XSS**: Injects malicious scripts into web pages\n- **Protection**: CSRF tokens for CSRF, input sanitization for XSS\n\n### Spring Security Filter Chain\nExplain the order and purpose of key security filters, how they process requests, and how custom filters can be added.\n\n## Interview Preparation Tips\n\n1. **Understand core concepts**: Authentication, authorization, principal, authorities\n2. **Know authentication mechanisms**: Form-based, JWT, OAuth 2.0, Basic auth\n3. **Master authorization strategies**: Role-based, method-level, expression-based\n4. **Study security vulnerabilities**: OWASP Top 10 and their prevention\n5. **Practice configuration**: Security filter chain, CORS, CSRF protection\n6. **Learn testing approaches**: Security testing annotations and strategies\n\nSpring Security provides comprehensive protection for enterprise applications. Focus on understanding security principles and how Spring Security implements them rather than memorizing configuration syntax."
  },
  {
    "title": "React Framework: Modern Frontend Development Concepts",
    "summary": "Essential React concepts including component architecture, hooks, state management, and performance optimization for building scalable user interfaces.",
    "author": "Tech Interview Guide",
    "tags": ["React", "Frontend", "JavaScript", "UI", "Interview"],
    "featuredImage": "https://images.unsplash.com/photo-1633356122544-f134324a6cee?w=800&h=400&fit=crop",
    "content": "# React Framework: Modern Frontend Development Concepts\n\n## React Fundamentals\n\n### What is React?\n\nReact is a JavaScript library for building user interfaces, particularly single-page applications. It uses a component-based architecture and virtual DOM for efficient rendering. React follows a declarative paradigm where you describe what the UI should look like for any given state.\n\n### Core Principles\n\n**Component-Based Architecture**: Applications are built as a tree of reusable components, each managing its own state and rendering logic.\n\n**Declarative Programming**: You describe what the UI should look like rather than how to manipulate the DOM directly.\n\n**Unidirectional Data Flow**: Data flows down from parent to child components through props, making applications predictable and easier to debug.\n\n**Virtual DOM**: React creates a virtual representation of the DOM in memory, enabling efficient updates through reconciliation.\n\n## Virtual DOM and Reconciliation\n\n### Virtual DOM Concept\n\nThe Virtual DOM is a JavaScript representation of the actual DOM. When state changes occur, React creates a new virtual DOM tree and compares it with the previous version.\n\n### Reconciliation Process\n\n1. **State Change**: Component state or props change\n2. **Virtual DOM Creation**: New virtual DOM tree is created\n3. **Diffing**: React compares new tree with previous tree\n4. **Reconciliation**: Minimal set of changes is calculated\n5. **DOM Update**: Only necessary changes are applied to real DOM\n\n### Benefits of Virtual DOM\n\n- **Performance**: Batch updates and minimal DOM manipulation\n- **Predictability**: Consistent rendering behavior\n- **Developer Experience**: Declarative programming model\n- **Cross-browser Compatibility**: Abstraction over DOM differences\n\n## Component Architecture\n\n### Functional vs Class Components\n\n**Functional Components** (Modern Approach):\n- Simpler syntax and easier to test\n- Use hooks for state and lifecycle management\n- Better performance optimization opportunities\n- Encouraged by React team\n\n**Class Components** (Legacy):\n- Traditional object-oriented approach\n- Built-in lifecycle methods\n- this.state for state management\n- Still supported but not recommended for new code\n\n### Component Composition\n\n**Composition over Inheritance**: React favors composition patterns over class inheritance for code reuse.\n\n**Higher-Order Components (HOCs)**: Functions that take a component and return a new component with additional functionality.\n\n**Render Props**: Pattern for sharing code between components using a prop whose value is a function.\n\n**Custom Hooks**: Extract component logic into reusable functions.\n\n## React Hooks\n\n### Hook Fundamentals\n\nHooks are functions that let you \"hook into\" React features from functional components. They follow specific rules:\n\n1. Only call hooks at the top level of functions\n2. Only call hooks from React functions (components or custom hooks)\n3. Hook names must start with \"use\"\n\n### Built-in Hooks\n\n**useState**: Manages local component state\n- Returns current state value and setter function\n- State updates are asynchronous and may be batched\n- Functional updates for state based on previous state\n\n**useEffect**: Handles side effects and lifecycle events\n- Combines componentDidMount, componentDidUpdate, and componentWillUnmount\n- Dependency array controls when effect runs\n- Cleanup function for resource management\n\n**useContext**: Consumes React context values\n- Avoids prop drilling for global state\n- Automatically re-renders when context value changes\n- Should be used judiciously to avoid performance issues\n\n**useReducer**: Manages complex state logic\n- Alternative to useState for complex state transitions\n- Similar to Redux pattern with actions and reducers\n- Useful when state logic involves multiple sub-values\n\n**useMemo**: Memoizes expensive calculations\n- Only recalculates when dependencies change\n- Helps prevent unnecessary re-computations\n- Should be used for genuinely expensive operations\n\n**useCallback**: Memoizes function references\n- Prevents unnecessary re-renders of child components\n- Useful when passing callbacks to optimized child components\n- Dependencies array determines when to create new function\n\n### Custom Hooks\n\nCustom hooks extract component logic into reusable functions:\n\n```javascript\n// Custom hook for API calls\nfunction useApi(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    // Fetch data logic\n  }, [url]);\n  \n  return { data, loading, error };\n}\n```\n\n## State Management\n\n### Local State vs Global State\n\n**Local State**: Managed within individual components using useState or useReducer. Suitable for component-specific data that doesn't need to be shared.\n\n**Global State**: Shared across multiple components. Can be managed through:\n- React Context API for simple global state\n- Redux for complex state management\n- Zustand, Recoil, or other state management libraries\n\n### Context API\n\nReact's built-in solution for sharing state across component trees:\n\n```javascript\nconst ThemeContext = createContext();\n\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  return (\n    <ThemeContext.Provider value={{ theme, setTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n```\n\n### State Management Best Practices\n\n- Keep state as local as possible\n- Lift state up when multiple components need access\n- Use Context API for truly global state\n- Consider external libraries for complex state logic\n- Normalize state structure for complex data\n\n## Component Lifecycle\n\n### Functional Component Lifecycle with Hooks\n\n**Mounting**: Component is being created and inserted into DOM\n- useEffect with empty dependency array mimics componentDidMount\n\n**Updating**: Component is being re-rendered due to prop or state changes\n- useEffect without dependency array runs on every render\n- useEffect with dependencies runs when dependencies change\n\n**Unmounting**: Component is being removed from DOM\n- useEffect cleanup function mimics componentWillUnmount\n\n### Effect Dependencies\n\nDependency arrays control when effects run:\n- No dependency array: Runs on every render\n- Empty dependency array []: Runs only on mount/unmount\n- With dependencies [dep1, dep2]: Runs when dependencies change\n\n## Performance Optimization\n\n### React.memo\n\nHigher-order component that memoizes component rendering:\n- Prevents re-renders when props haven't changed\n- Uses shallow comparison by default\n- Custom comparison function for complex props\n\n### useMemo and useCallback\n\n**useMemo**: Memoizes expensive calculations\n**useCallback**: Memoizes function references\n\nBoth help prevent unnecessary re-renders and re-computations.\n\n### Code Splitting\n\n**React.lazy**: Dynamically import components\n**Suspense**: Handle loading states for lazy components\n\n```javascript\nconst LazyComponent = React.lazy(() => import('./LazyComponent'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <LazyComponent />\n    </Suspense>\n  );\n}\n```\n\n### Performance Best Practices\n\n- Use React DevTools Profiler to identify performance bottlenecks\n- Avoid creating objects and functions in render methods\n- Use keys properly in lists\n- Implement proper shouldComponentUpdate logic\n- Consider virtualization for large lists\n\n## Event Handling\n\n### SyntheticEvents\n\nReact wraps native events in SyntheticEvent objects:\n- Cross-browser compatibility\n- Consistent API across different browsers\n- Event pooling for performance (deprecated in React 17+)\n- Access to native event through nativeEvent property\n\n### Event Delegation\n\nReact uses event delegation:\n- Single event listener on document root\n- Events bubble up to root and are dispatched to appropriate handlers\n- Improves performance for applications with many event listeners\n\n## Forms and Controlled Components\n\n### Controlled vs Uncontrolled Components\n\n**Controlled Components**: Form data is handled by React state\n- Single source of truth\n- Easier validation and manipulation\n- More predictable behavior\n\n**Uncontrolled Components**: Form data is handled by DOM\n- Less code for simple forms\n- Direct DOM access through refs\n- Harder to validate and manipulate\n\n### Form Handling Best Practices\n\n- Use controlled components for most cases\n- Implement proper validation\n- Handle form submission correctly\n- Provide good user feedback\n- Consider form libraries for complex forms\n\n## Error Boundaries\n\n### Error Handling in React\n\nError boundaries catch JavaScript errors in component trees:\n- Prevent entire application crashes\n- Display fallback UI for error states\n- Log errors for debugging\n- Only catch errors in render methods and lifecycle methods\n\n```javascript\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n  \n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n  \n  componentDidCatch(error, errorInfo) {\n    console.error('Error caught by boundary:', error, errorInfo);\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      return <h1>Something went wrong.</h1>;\n    }\n    return this.props.children;\n  }\n}\n```\n\n## Testing React Components\n\n### Testing Approaches\n\n**Unit Testing**: Test individual components in isolation\n**Integration Testing**: Test component interactions\n**End-to-End Testing**: Test complete user workflows\n\n### Testing Tools\n\n**Jest**: JavaScript testing framework\n**React Testing Library**: Testing utilities for React components\n**Enzyme**: Alternative testing utility (less popular now)\n**Cypress**: End-to-end testing framework\n\n### Testing Best Practices\n\n- Test behavior, not implementation details\n- Use semantic queries (getByRole, getByLabelText)\n- Test user interactions and workflows\n- Mock external dependencies appropriately\n- Maintain good test coverage\n\n## Common Interview Questions\n\n### Virtual DOM Benefits\n- Performance optimization through batched updates\n- Predictable rendering behavior\n- Cross-browser compatibility\n- Developer experience improvements\n\n### useState vs useReducer\n- useState: Simple state management\n- useReducer: Complex state logic with multiple actions\n- useReducer: When state depends on previous state\n- useReducer: Better for testing complex state transitions\n\n### useEffect Dependencies\n- Empty array []: Effect runs once on mount\n- No array: Effect runs on every render\n- With dependencies: Effect runs when dependencies change\n- Missing dependencies can cause bugs\n\n### Component Re-rendering\nComponents re-render when:\n- State changes\n- Props change\n- Parent component re-renders\n- Context value changes\n\n### Keys in Lists\n- Help React identify which items have changed\n- Should be stable, predictable, and unique\n- Avoid using array indices as keys\n- Important for performance and state preservation\n\n## Best Practices\n\n### Component Design\n- Keep components small and focused\n- Use composition over inheritance\n- Implement proper prop validation\n- Follow naming conventions\n- Separate concerns (presentation vs logic)\n\n### State Management\n- Keep state as local as possible\n- Use appropriate state management solutions\n- Normalize complex state structures\n- Avoid deeply nested state\n- Use immutable update patterns\n\n### Performance\n- Profile before optimizing\n- Use React DevTools for debugging\n- Implement proper memoization\n- Avoid premature optimization\n- Consider code splitting for large applications\n\n## Interview Preparation Tips\n\n1. **Understand core concepts**: Virtual DOM, components, hooks, state management\n2. **Practice with hooks**: Know when and how to use different hooks\n3. **Master state management**: Local state, Context API, external libraries\n4. **Study performance optimization**: Memoization, code splitting, profiling\n5. **Learn testing strategies**: Unit testing, integration testing, best practices\n6. **Know common patterns**: HOCs, render props, custom hooks, error boundaries\n\nReact's component-based architecture and declarative approach make it powerful for building modern user interfaces. Focus on understanding the underlying concepts and patterns rather than memorizing API details."
  },
  {
    "title": "Docker Containerization: Modern Application Deployment",
    "summary": "Understanding Docker containers, images, orchestration concepts, and containerization benefits for scalable application deployment and development workflows.",
    "author": "Tech Interview Guide",
    "tags": ["Docker", "Containerization", "DevOps", "Deployment", "Interview"],
    "featuredImage": "https://images.unsplash.com/photo-1605745341112-85968b19335b?w=800&h=400&fit=crop",
    "content": "# Docker Containerization: Modern Application Deployment\n\n## Docker Fundamentals\n\n### What is Docker?\n\nDocker is a containerization platform that packages applications and their dependencies into lightweight, portable containers. Containers provide consistent environments across development, testing, and production systems.\n\n### Core Concepts\n\n**Container**: A running instance of an image that includes the application and its runtime environment.\n\n**Image**: A read-only template containing application code, runtime, libraries, and dependencies.\n\n**Dockerfile**: A text file with instructions to build Docker images.\n\n**Registry**: A service for storing and distributing Docker images (Docker Hub, private registries).\n\n**Volume**: Persistent data storage that survives container lifecycle.\n\n**Network**: Communication channels between containers and external systems.\n\n## Containerization Benefits\n\n### Consistency Across Environments\n\nContainers ensure applications run identically across different environments:\n- Development laptops\n- Testing servers\n- Production infrastructure\n- Cloud platforms\n\n### Resource Efficiency\n\n**Lightweight**: Containers share the host OS kernel, using fewer resources than virtual machines.\n\n**Fast Startup**: Containers start in seconds compared to minutes for VMs.\n\n**High Density**: More containers can run on the same hardware compared to VMs.\n\n### Scalability and Portability\n\n**Horizontal Scaling**: Easy to scale applications by running multiple container instances.\n\n**Cloud Portability**: Containers run consistently across different cloud providers.\n\n**Microservices Architecture**: Ideal for breaking monolithic applications into smaller services.\n\n## Docker Architecture\n\n### Docker Engine\n\nThe core Docker runtime consisting of:\n\n**Docker Daemon**: Background service managing containers, images, networks, and volumes.\n\n**Docker CLI**: Command-line interface for interacting with Docker daemon.\n\n**REST API**: Programmatic interface for Docker operations.\n\n### Container Runtime\n\n**containerd**: High-level container runtime managing container lifecycle.\n\n**runc**: Low-level runtime that actually runs containers according to OCI specification.\n\n### Image Layers\n\nDocker images are built in layers:\n- Each instruction in Dockerfile creates a new layer\n- Layers are cached and reused across images\n- Only changed layers need to be rebuilt\n- Reduces storage space and build time\n\n## Dockerfile Best Practices\n\n### Multi-Stage Builds\n\nUse multiple FROM statements to create smaller production images:\n\n```dockerfile\n# Build stage\nFROM node:16 AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci\nCOPY . .\nRUN npm run build\n\n# Production stage\nFROM nginx:alpine\nCOPY --from=builder /app/dist /usr/share/nginx/html\n```\n\n### Layer Optimization\n\n- Order instructions from least to most frequently changing\n- Combine RUN commands to reduce layers\n- Use .dockerignore to exclude unnecessary files\n- Clean up package caches in the same RUN command\n\n### Security Considerations\n\n- Use official base images from trusted sources\n- Run containers as non-root users\n- Keep base images updated\n- Scan images for vulnerabilities\n- Use minimal base images (alpine, distroless)\n\n## Container Networking\n\n### Network Types\n\n**Bridge Network**: Default network for containers on single host.\n\n**Host Network**: Container uses host's network stack directly.\n\n**Overlay Network**: Multi-host networking for container clusters.\n\n**None Network**: Container has no network access.\n\n### Service Discovery\n\nContainers can communicate using:\n- Container names as hostnames\n- Service discovery mechanisms\n- Environment variables\n- External service registries\n\n### Port Mapping\n\nMap container ports to host ports for external access:\n\n```bash\ndocker run -p 8080:80 nginx  # Host port 8080 -> Container port 80\n```\n\n## Data Management\n\n### Volume Types\n\n**Named Volumes**: Managed by Docker, stored in Docker area.\n\n**Bind Mounts**: Mount host directories into containers.\n\n**tmpfs Mounts**: Store data in host memory (temporary).\n\n### Data Persistence Strategies\n\n- Use volumes for database data\n- Bind mounts for development workflows\n- Separate data from application containers\n- Backup and restore volume data\n\n### Volume Best Practices\n\n- Never store persistent data in container layers\n- Use named volumes for production data\n- Implement proper backup strategies\n- Consider data encryption for sensitive information\n\n## Docker Compose\n\n### Multi-Container Applications\n\nDocker Compose defines and runs multi-container applications using YAML configuration:\n\n```yaml\nversion: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - database\n  database:\n    image: postgres:13\n    environment:\n      POSTGRES_DB: myapp\n      POSTGRES_PASSWORD: secret\n    volumes:\n      - db_data:/var/lib/postgresql/data\nvolumes:\n  db_data:\n```\n\n### Compose Benefits\n\n- Define entire application stack in single file\n- Easy development environment setup\n- Service dependencies and startup order\n- Environment-specific configurations\n- Integration with Docker Swarm for production\n\n## Container Orchestration\n\n### Orchestration Needs\n\nAs applications grow, manual container management becomes challenging:\n- Service discovery and load balancing\n- Health monitoring and auto-recovery\n- Scaling based on demand\n- Rolling updates and rollbacks\n- Resource allocation and scheduling\n\n### Orchestration Platforms\n\n**Docker Swarm**: Docker's native orchestration solution\n- Simple setup and management\n- Good for smaller deployments\n- Integrated with Docker ecosystem\n\n**Kubernetes**: Industry-standard orchestration platform\n- Powerful and feature-rich\n- Large ecosystem and community\n- Complex but highly scalable\n\n**Amazon ECS**: AWS container orchestration service\n- Tight AWS integration\n- Managed service with less operational overhead\n\n## Security Best Practices\n\n### Image Security\n\n- Use official and verified images\n- Regularly update base images\n- Scan images for vulnerabilities\n- Use minimal base images\n- Implement image signing and verification\n\n### Runtime Security\n\n- Run containers as non-root users\n- Use read-only filesystems when possible\n- Limit container capabilities\n- Implement resource limits\n- Use security profiles (AppArmor, SELinux)\n\n### Network Security\n\n- Use custom networks instead of default bridge\n- Implement network segmentation\n- Use TLS for inter-service communication\n- Restrict container network access\n- Monitor network traffic\n\n## Monitoring and Logging\n\n### Container Monitoring\n\nMonitor container metrics:\n- CPU and memory usage\n- Network I/O\n- Disk usage\n- Container health status\n- Application-specific metrics\n\n### Logging Strategies\n\n**Centralized Logging**: Aggregate logs from all containers\n\n**Log Drivers**: Configure how Docker handles container logs\n\n**Structured Logging**: Use JSON or other structured formats\n\n**Log Rotation**: Prevent log files from consuming too much disk space\n\n### Monitoring Tools\n\n- Docker stats command for basic metrics\n- Prometheus and Grafana for comprehensive monitoring\n- ELK stack (Elasticsearch, Logstash, Kibana) for logging\n- Cloud-native monitoring solutions\n\n## Development Workflows\n\n### Development Environment\n\nUse Docker for consistent development environments:\n- Same runtime as production\n- Easy onboarding for new developers\n- Isolated dependencies\n- Version-controlled environment configuration\n\n### CI/CD Integration\n\nIntegrate Docker into CI/CD pipelines:\n- Build images in CI pipeline\n- Run tests in containers\n- Push images to registries\n- Deploy containers to production\n- Implement automated rollbacks\n\n### Testing Strategies\n\n- Unit tests in container environments\n- Integration tests with Docker Compose\n- Performance testing with realistic container setups\n- Security testing of container images\n\n## Common Interview Questions\n\n### Docker vs Virtual Machines\n\n**Docker Containers**:\n- Share host OS kernel\n- Lightweight and fast startup\n- Better resource utilization\n- Process-level isolation\n\n**Virtual Machines**:\n- Full OS virtualization\n- Stronger isolation\n- More resource overhead\n- Hardware-level virtualization\n\n### Container vs Image\n\n**Image**: Static template with application and dependencies\n**Container**: Running instance of an image\n**Analogy**: Image is like a class, container is like an object instance\n\n### Dockerfile Instructions\n\n- **FROM**: Base image\n- **RUN**: Execute commands during build\n- **COPY/ADD**: Copy files into image\n- **WORKDIR**: Set working directory\n- **EXPOSE**: Document port usage\n- **CMD/ENTRYPOINT**: Define container startup command\n\n### Data Persistence\n\nExplain different volume types and when to use each:\n- Named volumes for production data\n- Bind mounts for development\n- tmpfs for temporary data\n\n### Container Networking\n\nDescribe how containers communicate:\n- Within same network using container names\n- Port mapping for external access\n- Custom networks for isolation\n- Service discovery mechanisms\n\n## Performance Optimization\n\n### Image Optimization\n\n- Use multi-stage builds\n- Minimize layer count\n- Use appropriate base images\n- Implement proper caching strategies\n- Remove unnecessary files and dependencies\n\n### Runtime Optimization\n\n- Set appropriate resource limits\n- Use health checks for reliability\n- Implement proper logging configuration\n- Monitor and tune container performance\n- Use container orchestration for scaling\n\n### Build Optimization\n\n- Optimize Dockerfile instruction order\n- Use build cache effectively\n- Implement parallel builds when possible\n- Use BuildKit for advanced features\n- Minimize build context size\n\n## Interview Preparation Tips\n\n1. **Understand core concepts**: Containers, images, Dockerfile, volumes, networks\n2. **Know the benefits**: Consistency, portability, scalability, resource efficiency\n3. **Practice with Dockerfile**: Multi-stage builds, optimization techniques\n4. **Study networking**: How containers communicate, port mapping, service discovery\n5. **Learn orchestration basics**: Docker Swarm, Kubernetes concepts\n6. **Understand security**: Best practices for secure containerization\n7. **Know monitoring approaches**: Logging, metrics, health checks\n\nDocker has revolutionized application deployment and development workflows. Focus on understanding the fundamental concepts and benefits rather than memorizing specific commands. The key is to grasp how containerization solves real-world problems in software development and deployment."
  },
  {
    "title": "MySQL and Database Design: Relational Database Mastery",
    "summary": "Comprehensive guide to MySQL database concepts, SQL optimization, indexing strategies, and database design principles for scalable applications.",
    "author": "Tech Interview Guide",
    "tags": ["MySQL", "Database", "SQL", "Performance", "Interview"],
    "featuredImage": "https://images.unsplash.com/photo-1544383835-bda2bc66a55d?w=800&h=400&fit=crop",
    "content": "# MySQL and Database Design: Relational Database Mastery\n\n## Database Fundamentals\n\n### What is MySQL?\n\nMySQL is an open-source relational database management system (RDBMS) that uses Structured Query Language (SQL) for database operations. It's widely used for web applications and supports ACID transactions, making it reliable for business-critical applications.\n\n### ACID Properties\n\n**Atomicity**: Transactions are all-or-nothing operations. Either all changes are committed or none are applied.\n\n**Consistency**: Database remains in a valid state before and after transactions, maintaining all defined rules and constraints.\n\n**Isolation**: Concurrent transactions don't interfere with each other, appearing to execute sequentially.\n\n**Durability**: Committed changes persist even in case of system failures.\n\n### Relational Model\n\n**Tables**: Store data in rows and columns\n**Primary Keys**: Uniquely identify each row\n**Foreign Keys**: Establish relationships between tables\n**Constraints**: Enforce data integrity rules\n**Normalization**: Organize data to reduce redundancy\n\n## Database Design Principles\n\n### Normalization\n\nNormalization eliminates data redundancy and improves data integrity:\n\n**First Normal Form (1NF)**:\n- Each column contains atomic values\n- No repeating groups or arrays\n- Each row is unique\n\n**Second Normal Form (2NF)**:\n- Must be in 1NF\n- All non-key attributes depend on entire primary key\n- Eliminates partial dependencies\n\n**Third Normal Form (3NF)**:\n- Must be in 2NF\n- No transitive dependencies\n- Non-key attributes depend only on primary key\n\n**Boyce-Codd Normal Form (BCNF)**:\n- Stricter version of 3NF\n- Every determinant is a candidate key\n\n### Denormalization\n\nSometimes denormalization is used for performance:\n- Reduces complex joins\n- Improves read performance\n- Increases storage requirements\n- Requires careful maintenance of data consistency\n\n### Entity-Relationship Modeling\n\n**Entities**: Objects or concepts (Customer, Order, Product)\n**Attributes**: Properties of entities (name, email, price)\n**Relationships**: Associations between entities (one-to-one, one-to-many, many-to-many)\n\n## SQL Query Optimization\n\n### Query Execution Process\n\n1. **Parsing**: SQL syntax validation and parsing\n2. **Optimization**: Query optimizer creates execution plan\n3. **Execution**: Database engine executes the plan\n4. **Result**: Data is returned to client\n\n### Query Optimization Techniques\n\n**Use Appropriate Indexes**: Create indexes on frequently queried columns\n\n**Avoid SELECT ***: Specify only needed columns to reduce data transfer\n\n**Use WHERE Clauses Effectively**: Filter data as early as possible\n\n**Optimize JOIN Operations**: Use appropriate join types and order\n\n**Limit Result Sets**: Use LIMIT clause to reduce data transfer\n\n### EXPLAIN Statement\n\nUse EXPLAIN to analyze query execution plans:\n\n```sql\nEXPLAIN SELECT u.name, o.total \nFROM users u \nJOIN orders o ON u.id = o.user_id \nWHERE u.status = 'active';\n```\n\nKey metrics to analyze:\n- **type**: Join type (const, eq_ref, ref, range, index, ALL)\n- **rows**: Estimated rows examined\n- **key**: Index used\n- **Extra**: Additional information about query execution\n\n## Indexing Strategies\n\n### Index Types\n\n**Primary Index**: Automatically created for primary keys\n**Unique Index**: Ensures uniqueness and improves query performance\n**Composite Index**: Covers multiple columns\n**Partial Index**: Indexes subset of rows based on condition\n**Full-Text Index**: For text search operations\n\n### Index Design Principles\n\n**Selectivity**: High selectivity indexes are more effective\n**Cardinality**: Number of unique values in indexed column\n**Column Order**: In composite indexes, most selective columns first\n**Covering Indexes**: Include all columns needed by query\n\n### When to Use Indexes\n\n**Create indexes for**:\n- Primary keys (automatic)\n- Foreign keys\n- Frequently searched columns\n- Columns used in ORDER BY\n- Columns used in JOIN conditions\n\n**Avoid indexes for**:\n- Small tables\n- Columns with low selectivity\n- Frequently updated columns\n- Tables with high insert/update ratio\n\n## Transaction Management\n\n### Transaction Isolation Levels\n\n**READ UNCOMMITTED**: Lowest isolation, allows dirty reads\n**READ COMMITTED**: Prevents dirty reads, allows non-repeatable reads\n**REPEATABLE READ**: Prevents dirty and non-repeatable reads (MySQL default)\n**SERIALIZABLE**: Highest isolation, prevents all phenomena\n\n### Locking Mechanisms\n\n**Shared Locks**: Multiple transactions can read same data\n**Exclusive Locks**: Only one transaction can modify data\n**Row-Level Locking**: Locks individual rows (InnoDB)\n**Table-Level Locking**: Locks entire table (MyISAM)\n\n### Deadlock Prevention\n\n- Access tables in consistent order\n- Keep transactions short\n- Use appropriate isolation levels\n- Implement retry logic for deadlock errors\n\n## Storage Engines\n\n### InnoDB (Default)\n\n**Features**:\n- ACID compliance\n- Row-level locking\n- Foreign key constraints\n- Crash recovery\n- Multi-version concurrency control (MVCC)\n\n**Best for**: OLTP applications, high concurrency\n\n### MyISAM\n\n**Features**:\n- Table-level locking\n- Fast for read-heavy workloads\n- Full-text indexing\n- No transaction support\n\n**Best for**: Read-heavy applications, data warehousing\n\n### Memory (HEAP)\n\n**Features**:\n- Stores data in RAM\n- Very fast access\n- Data lost on restart\n- Hash indexes\n\n**Best for**: Temporary data, caching\n\n## Performance Tuning\n\n### Configuration Optimization\n\n**innodb_buffer_pool_size**: Cache for InnoDB data and indexes\n**query_cache_size**: Cache for SELECT query results\n**max_connections**: Maximum concurrent connections\n**innodb_log_file_size**: Size of transaction log files\n\n### Query Performance\n\n**Slow Query Log**: Identify slow-running queries\n**Query Cache**: Cache frequently executed queries\n**Connection Pooling**: Reuse database connections\n**Prepared Statements**: Reduce parsing overhead\n\n### Monitoring and Metrics\n\nKey metrics to monitor:\n- Query response time\n- Throughput (queries per second)\n- Connection usage\n- Buffer pool hit ratio\n- Lock wait time\n- Replication lag\n\n## Backup and Recovery\n\n### Backup Types\n\n**Logical Backups**: Export data as SQL statements\n- mysqldump utility\n- Portable across platforms\n- Slower for large databases\n\n**Physical Backups**: Copy database files directly\n- Faster for large databases\n- Platform-specific\n- Requires consistent state\n\n### Backup Strategies\n\n**Full Backup**: Complete database backup\n**Incremental Backup**: Changes since last backup\n**Differential Backup**: Changes since last full backup\n**Point-in-Time Recovery**: Restore to specific timestamp\n\n### High Availability\n\n**Master-Slave Replication**: Read scaling and backup\n**Master-Master Replication**: Active-active setup\n**MySQL Cluster**: Distributed computing solution\n**Failover Mechanisms**: Automatic switching to backup systems\n\n## Security Best Practices\n\n### Authentication and Authorization\n\n- Use strong passwords\n- Implement principle of least privilege\n- Create specific users for applications\n- Regularly audit user permissions\n- Use SSL/TLS for connections\n\n### Data Protection\n\n**Encryption at Rest**: Encrypt database files\n**Encryption in Transit**: Use SSL/TLS connections\n**Data Masking**: Hide sensitive data in non-production environments\n**Audit Logging**: Track database access and changes\n\n### SQL Injection Prevention\n\n- Use parameterized queries/prepared statements\n- Validate and sanitize input\n- Implement proper error handling\n- Use stored procedures when appropriate\n- Apply principle of least privilege\n\n## NoSQL vs SQL Comparison\n\n### When to Use SQL (MySQL)\n\n- Complex relationships between data\n- ACID compliance requirements\n- Complex queries and reporting\n- Mature ecosystem and tools\n- Strong consistency requirements\n\n### When to Consider NoSQL\n\n- Rapid development and iteration\n- Horizontal scaling requirements\n- Unstructured or semi-structured data\n- High-volume, high-velocity data\n- Eventual consistency acceptable\n\n### Popular NoSQL Databases\n\n**MongoDB**: Document database\n**Redis**: Key-value store\n**Cassandra**: Wide-column store\n**Neo4j**: Graph database\n\n## Common Interview Questions\n\n### ACID Properties\nExplain each property with examples:\n- Atomicity: Bank transfer example\n- Consistency: Referential integrity\n- Isolation: Concurrent transaction scenarios\n- Durability: System crash recovery\n\n### Normalization vs Denormalization\n- Normalization reduces redundancy, improves consistency\n- Denormalization improves read performance, increases storage\n- Trade-offs between storage, consistency, and performance\n\n### Index Types and Usage\n- Primary, unique, composite, partial indexes\n- When to create indexes\n- Index maintenance overhead\n- Covering indexes for query optimization\n\n### Transaction Isolation Levels\n- Read phenomena: dirty read, non-repeatable read, phantom read\n- Isolation levels and what they prevent\n- Performance vs consistency trade-offs\n\n### Query Optimization\n- EXPLAIN plan analysis\n- Index usage strategies\n- JOIN optimization techniques\n- Subquery vs JOIN performance\n\n### Replication and High Availability\n- Master-slave vs master-master replication\n- Replication lag and consistency\n- Failover strategies\n- Backup and recovery procedures\n\n## Best Practices\n\n### Database Design\n\n- Follow normalization principles appropriately\n- Use appropriate data types\n- Implement proper constraints\n- Design for scalability\n- Document database schema\n\n### Query Writing\n\n- Use parameterized queries\n- Avoid SELECT * in production code\n- Use appropriate JOIN types\n- Implement proper error handling\n- Consider query performance impact\n\n### Performance\n\n- Monitor query performance regularly\n- Use indexes strategically\n- Implement connection pooling\n- Optimize configuration parameters\n- Plan for capacity growth\n\n### Security\n\n- Implement proper authentication\n- Use principle of least privilege\n- Encrypt sensitive data\n- Regular security audits\n- Keep database software updated\n\n## Interview Preparation Tips\n\n1. **Master SQL fundamentals**: SELECT, JOIN, subqueries, window functions\n2. **Understand database design**: Normalization, ER modeling, constraints\n3. **Know indexing strategies**: When and how to create effective indexes\n4. **Study transaction concepts**: ACID properties, isolation levels, locking\n5. **Learn optimization techniques**: Query tuning, EXPLAIN plans, performance monitoring\n6. **Understand backup/recovery**: Different backup types, recovery strategies\n7. **Know security practices**: SQL injection prevention, encryption, access control\n\nMySQL and relational databases remain fundamental to most applications. Focus on understanding core concepts, performance optimization, and design principles rather than memorizing syntax. The key is to demonstrate how database design decisions impact application performance, scalability, and maintainability."
  }
]
